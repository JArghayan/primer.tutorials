---
title: "Probability: Rolling Dice"
author: Yuhan Wu
tutorial:
  id: probability-rolling-dice
output:
  learnr::tutorial:
    progressive: yes
    allow_skip: yes
runtime: shiny_prerendered
description: "Exploring simple dice rolls under various scenarios."
---

```{r setup, include = FALSE}
library(learnr)
library(primer.tutorials)
library(tidyverse)
library(primer.data)
library(forcats)
knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 
```

```{r copy-code-chunk, child = "../../child_documents/copy_button.Rmd"}
```

```{r info-section, child = "../../child_documents/info_section.Rmd"}
```

<!-- DK: Graphic for weighted die should be from 2 to 12, not 5 to 12. Maybe cheat a bit and choose a set seed which produces a 50 sample graphic that might fool us. -->

<!-- Review all current code and clean it up. -->

<!-- Key insight: We are in the business of comparing the model --- a data generating mechanism (DGM) which we create with code --- with the data. In particular, we simulate from 10,000 draws (or create or just draw) from the DGM. Then, we look at the data we have. How well do those match up? If they match up OK, then we are good! If they match up poorly, we need a new DGM.  -->


<!-- Perhaps use the Statistical Rethinking chapter 2 example which is similar to, but more complex than, our  -->




## Introduction
###

Official Definition : We use the term 'data-generating mechanism' to denote how random numbers are used to generate a dataset." 


Data generating mechanism is by it's name to generates data that we need in order to solve problems. We can generates data because we assume that we know the mathematical formula for the population of data which is the infinite set of data we want and need. 

In this tutorials you will be able to answer the following questions.

How sample size will effect empirical distribution and data generating mechanism?

How does different assumptions change the DGM ?

How to determine if the assumptions for DGM is false?




## Two dice

### 

The larger the sample size, the more closely your empirical distribution will match the data generating mechanism (DGM) **if** your assumptions about the DGM are correct.

### 

For example, you might think that the two dice are fair and that, therefore, the data generating mechanism --- which is a tool you can use, for example, to forecast future rolls --- is defined as:

<!-- DK: Not sure I like this p_x(X) stuff. Need to revisit, both here and in the Primer. -->

$$ p_Y(y) = \begin{cases} \dfrac{y-1}{36} &\text{for }y=1,2,3,4,5,6 \\ \dfrac{13-y}{36} &\text{for }y=7,8,9,10,11,12 \\ 0 &\text{otherwise} \end{cases} $$

This is, of course, the mathematical distribution for fair dice. Graphically, it looks like:


```{r}
tibble(sum = c(rep(c(2, 12), 1), 
               rep(c(3, 11), 2),
               rep(c(4, 10), 3), 
               rep(c(5,  9), 4),
               rep(c(6,  8), 5),
               rep(c(7), 6))) %>% 
  ggplot(aes(x = sum)) +
  geom_histogram(aes(y = after_stat(count/sum(count))), 
                   binwidth = 1, 
                   color = "white") +
  labs(title = "Mathematical Probability Distribution",
         subtitle = "Expectation for the sum from rolling two dice",
         x = "Outcome\nSum of Two Die",
         y = "Probability") +
  scale_x_continuous(breaks = seq(2, 12, 1), labels = 2:12) +
  scale_y_continuous(labels = 
                         scales::percent_format(accuracy = 1)) +
  theme_classic()
```

###


This is the plot we will replicate.

```{r}
# Turn your N column into a factor and then give it the levels in the order you
# want it to be. Maybe use forcats. Consider having the plot by 6 x 1. Or maybe
# stacked but with only 4 N values.


set.seed(2)
dice_p <- tibble(N = c(rep("10", 10), 
                       rep("20", 20),
                       rep("50", 50),
                       rep("100", 100),
                       rep("1000", 1000),
                       rep("10000", 10000))) %>%
  mutate(die_1 = map_dbl(N, ~ sample(c(1:6), size = 1))) %>% 
  mutate(die_2 = map_dbl(N, ~ sample(c(1:6), size = 1))) %>% 
  mutate(result = die_1 + die_2) %>%
  mutate(N = as.factor(N)) %>%
  mutate(N = fct_inseq(N)) %>%
  summarise(N, result) %>%
  ggplot(aes(x = result)) +
    geom_histogram(aes(y = stat(density)),
                   binwidth = 1, 
                   color = "white") +
    labs(title = "Empirical Probability Distribution",
           subtitle = "Sum from rolling two dice, Sample size changes",
           x = "Outcome\nSum of Two Die",
           y = "Probability") +
    facet_wrap(~ N, scales = "free") +
    scale_x_continuous(breaks = seq(2, 12, 1), labels = 2:12) +
    scale_y_continuous(labels= scales::percent_format(accuracy = 1))

dice_p

#dice_p use to show the distribution

```

The more data you have, the more that the empirical distribution will match the data generating mechanism, if your assumptions about the DGM are correct.


### Exercise 1

Before we begin, write two sentences explaining what is a *Empirical Probability Distribution*.


```{r rolling-two-dice-1}
question_text(NULL,
	message = "Empirical Probability Distribution is a type of distribution that is completely based on data.",
	answer(NULL,
	correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

<!-- DK: Make answers good! -->


### Exercise 2

Use the `rep()` to repeat the value "10" three times.

```{r rolling-two-dice-2, exercise = TRUE}

```

```{r rolling-two-dice-2-hint-1, eval = FALSE}
rep(10 , = )
```

### Exercise 3

Create a tibble (with `tibble()`) which has one variable, `x`, with the value of `rep(10, 3)`.

```{r rolling-two-dice-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-3-hint-1, eval = FALSE}
tibble(C = rep(10, 3))
```

### Exercise 4

Modify your answer to the previous exercise by using `c()` so that `x` has a value which includes `rep(10, 3)` and `rep(500, 2)`.

```{r rolling-two-dice-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-4-hint-1, eval = FALSE}
tibble(x = c(rep(10, 3), rep(500, 2)))
```

### 

Your tibble should have 5 rows.

### Exercise 5

Pipe down your result, use `mutate()` to add a new variable "dice" and have "dice" equal to an random values from 1 : 6 using `sample()`, 
```{r rolling-two-dice-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-5-hint-1, eval = FALSE}
... %>%
  mutate(dice = sample(1:6))
```

### 

This should return an error saying dice` must be size 5 or 1, not 6.


### Exercise 6

We only want one value from 1 to 6, so add in another argument `size` and set it equal to 1.
```{r rolling-two-dice-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-6-hint-1, eval = FALSE}
... %>%
  mutate(dice = sample(1:6, size = 1))
```

### 

Notice the column dice will always return the same number, this is what we don't want. In order to fix this we need to use the map_* function.


### Exercise 7

Use `map_dbl()` and set the first argument to C and formula to the `sample()` function we create in the last exercise. 
```{r rolling-two-dice-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-7-hint-1, eval = FALSE}
mutate(dice = map_dbl(C, ~sample(1:6, size = 1)))
```

### 

Now let's move in to the real game.


### Exercise 8

<!-- DK: Split this into 3 or 4 separate questions. And then, ask this question. Firts, question has answer of rep(10, 3). Second question has answer of tibble(N = rep(10, 3)). Third question has answer of tibble(N = c(rep(10, 3), rep(500, 2))). Fourth question has answer  tibble(N = c(rep(10, 3), rep(500, 2))) %>%  mutate(result = ...) -->

Create a `tibble()` with variable `N`, and set N to a list of value representing our sample size, then use `rep()` to repeat the function same numbers of times as the sample size. We want 6 different sample size: 10, 20, 50, 100, 1000, 100000.

```{r rolling-two-dice-8, exercise = TRUE}

```

```{r rolling-two-dice-8-hint-1, eval = FALSE}
tibble(N = c(rep("...", ...), 
             rep("...", ...),
             rep("...", ...),
             rep("...", ...),
             rep("...", ...),
             rep("...", ...)))
```

```{r rolling-two-dice-8-hint-2, eval = FALSE}
tibble(N = c(rep("10", 10), 
             rep("20", 20),
             rep("...", ...),
             rep("...", ...),
             rep("...", ...),
             rep("...", ...)))
```

### Exercise 9

Recall exercise 7, let's create another dice,set it equal to one of the 6 value from (1,2,3,4,5,6) for each rows of N using both map_dbl() and `sample()`, lastly assign it to the name "die_1" using `mutate().`
```{r rolling-two-dice-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-9-hint-1, eval = FALSE}
... %>%
mutate(...= map_dbl(..., ~ ...))
```

```{r rolling-two-dice-9-hint-2, eval = FALSE}
... %>%
mutate(...= map_dbl(N, ~sample(c(...: ...), size = 1)))
```

### Exercise 10

Copy and paste the results from above, and do the exact same thing again but instead now named to value to `die_2`, because we need the results for two dices.

```{r rolling-two-dice-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-10-hint-1, eval = FALSE}
... %>%
mutate(...= map_dbl(N, ~sample(c(...:...), size = 1)))
```

### Exercise 11

Copy and paste the results from above, use the `mutate()` function once again, name the value of the sum of `die_1` and `die_2` to "result"

```{r rolling-two-dice-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-11-hint-1, eval = FALSE}
... %>%
mutate(result = die_1 + die_2)
```

### Exercise 12

Copy and paste the above, then use `summarise()` to include the column "N" and "result" only

```{r rolling-two-dice-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-12-hint-1, eval = FALSE}
summarise(N, ...)
```

### Exercise 13

Copy and paste the code above, use `ggplot()` to graph the Empirical Distribution, set `x = result` within `aes()`, and then add a layer of `geom_histogram()`

```{r rolling-two-dice-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-13-hint-1, eval = FALSE}
... %>%
  ggplot(aes(x = ...)) +
    geom_histogram()
```

### Exercise 14

Copy and paste your code from above, recalled `facet_wrap()`, use `facet_wrap()` to separate the graph into six small distribution, don't forget the `~` within `facet_wrap()`.

```{r rolling-two-dice-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-14-hint-1, eval = FALSE}
...+
  facet_wrap(...)
```

```{r rolling-two-dice-14-hint-2, eval = FALSE}
... +
  facet_wrap(~ N)
```

Your graph should looks similar to this.
```{r}
tibble(N = c(rep("10", 10), 
             rep("20", 20),
             rep("50", 50),
             rep("100", 100),
             rep("1000", 1000),
             rep("10000", 10000))) %>%
  mutate(die_1 = map_dbl(N, ~ sample(c(1:6), size = 1))) %>% 
  mutate(die_2 = map_dbl(N, ~ sample(c(1:6), size = 1))) %>% 
  mutate(result = die_1 + die_2) %>%
  ggplot(aes(x = result)) +
  geom_histogram() +
  facet_wrap(~ N)
```

### Exercise 15

Now we have a graph, but it's not looking very good, it seems like we only have the 10000 strip fills up with bars. This is because the 10000 scales is so big, that the bars in other strip is blocked. In order for them to shows, within `facet_wrap()`, add another argument `scales`, and set it equal to "free". 
```{r rolling-two-dice-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-15-hint-1, eval = FALSE}
...+
facet_wrap( ~ ..., scales = "...")
```

This allows the graph to use it's own scale, instead an universal scales that covered all plots.

Your graph should looks like this
```{r}
set.seed(2)
tibble(N = c(rep("10", 10), 
             rep("20", 20),
             rep("50", 50),
             rep("100", 100),
             rep("1000", 1000),
             rep("10000", 10000))) %>%
  mutate(die_1 = map_dbl(N, ~ sample(c(1:6), size = 1))) %>% 
  mutate(die_2 = map_dbl(N, ~ sample(c(1:6), size = 1))) %>% 
  mutate(result = die_1 + die_2) %>%
  ggplot(aes(x = result)) +
  geom_histogram() +
  facet_wrap(~ N,scales = "free")
```

### Exercise 16

Copy and paste your results from above. Note that you see the red `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Let's get rid of this by adjusting binwidth for our plots, within `geom_histogram()` set "binwidth" equal to 1, and "color" between bins equal to "white".
```{r rolling-two-dice-16, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-16-hint-1, eval = FALSE}
...+
geom_histogram(binwidth = ..., color = "...") +
  ...
```

```{r rolling-two-dice-16-hint-2, eval = FALSE}
... %>%
  ggplot(aes(x = result)) +
  geom_histogram(binwidth = 1, color = "white") +
  facet_wrap(~ N,scales = "free")
```

### 

Notice the panal(gray bar) above each of the sixth distributions, they are out of order, we want to place them like this (10,20,50,100,1000,10000) so that we can see the evolution of the shape of the graph as the sample size increase.

### 

### Exercise 17

Go back to your previous code, right after the `summarize()` and before your `ggplot()`, use `mutate()` and `as.factor()` to reformat N into factor.

```{r rolling-two-dice-17, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-17-hint-1, eval = FALSE}
mutate(N = as.factor(N))
```

### Exercise 18

Pipe down your results, now do the exact same thing again for N, use `mutate()`, but this time we use th new function `fct_inseq()` to replace `as.factor()`, this allow us to ordered the in sequnce from small to large.

```{r rolling-two-dice-18, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-18-hint-1, eval = FALSE}
mutate(N = fct_inseq(N))
```

### Exercise 19

Copy and paste your code from above. Now look at the values on the y-axis, for each one of the sixth plot the value is different, this is because we have different sample size, and it makes sense for each to have different *count*. In order to create an *Empirical Probability distribution*. In order to *normalized* the plot, Within `geom_histogram()`, use `aes()` . Inside `aes()`, we use the argument `y = stat(density)` to set it to put percent on y-axis.

```{r rolling-two-dice-19, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-19-hint-1, eval = FALSE}
... +
    geom_histogram(aes(y = stat(...))) +
  ...
```

```{r include = FALSE}
set.seed(2)
tibble(N = c(rep("10", 10), 
             rep("20", 20),
             rep("50", 50),
             rep("100", 100),
             rep("1000", 1000),
             rep("10000", 10000))) %>%
  mutate(die_1 = map_dbl(N, ~ sample(c(1:6), size = 1))) %>% 
  mutate(die_2 = map_dbl(N, ~ sample(c(1:6), size = 1))) %>% 
  mutate(result = die_1 + die_2) %>%
  mutate(N = as.factor(N)) %>%
  mutate(N = fct_inseq(N)) %>%
  ggplot(aes(x = result)) +
  geom_histogram(aes(y = stat(density)),binwidth = 1, color = "white") +
  facet_wrap(~ N,scales = "free")
```

### Exercise 20

Now use `scale_x_continuous()` so the x-axis has `breaks` to the sequence between 2 and 12 common difference is 1 using `seq()`. Set the `labels` for the breaks as from 2 to 12.

```{r rolling-two-dice-20, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-20-hint-1, eval = FALSE}
... +
scale_x_continuous(breaks = seq(...,..., ...), labels = ...:...) 
```

```{r rolling-two-dice-20-hint-2, eval = FALSE}
... +
  scale_x_continuous(breaks = seq(2, 12, 1), labels = 2:12)
```

### Exercise 21

Now use `scale_y_continuous()` to put the x-axis in percent format. Within `scale_y_continuous()`, set `labels` to `scales::percent_format()`. Within `percent_format()` set `accuracy` to 1.

```{r rolling-two-dice-21, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-21-hint-1, eval = FALSE}
... +
  scale_y_continuous(labels = scales::percent_format(...))
```

### Exercise 22

Finally, use `labs()` to add the appropriate title, subtitle, and axis labels.

```{r rolling-two-dice-22, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>


```{r rolling-two-dice-22-hint-1, eval = FALSE}
... +
  labs(title = "...",subtitle = "...")
```

Reminder: Your plot should look similar to the the one below. 

```{r}
dice_p
```

###

The larger the sample size, the more closely your empirical distribution will match the data generating mechanism (DGM) **if** your assumptions about the DGM are correct.

## Weighted dice
###

If your assumptions about the process which generates the data (i.e., the data generating mechanism) are false, then it may take a lot of data to see evidence for that falseness. 

###

Consider this plot:

```{r}
dicefalse_p <- tibble(m = c(rep("10", 10), 
                           rep("50", 50),
                           rep("10000", 10000))) %>%
  mutate(die_1 = map_dbl(m, ~ sample(1:6, 
                                     size = 1, 
                                     prob = c(0.1, 0.1,  0.1, 
                                              0.1, 0.25, 0.35)))) %>% 
   mutate(die_2 = map_dbl(m, ~ sample(1:6, 
                                      size = 1,
                                      prob = c(0.1, 0.1, 0.1, 
                                               0.1, 0.25, 0.35)))) %>% 
   mutate(result = die_1 + die_2) %>%
   mutate(m = as.factor(m)) %>%
   mutate(m = fct_inseq(m)) %>%
   summarise(m,result) %>%
   ggplot(aes(x=result))+
   geom_histogram( aes(y = stat(density)),
                   binwidth = 1, 
                   color = "white") +
   labs(title = "Empirical Probability Distribution (Bad assumtions)",
         subtitle = "Sum from rolling two dice, sample size change",
         x = "Outcome\nSum of Two Die",
         y = "Probability") +
   facet_wrap(~ m, scales = "free")+
   scale_x_continuous(breaks = seq(2, 12, 1), labels = 2:12) +
   scale_y_continuous(labels = scales::percent_format(accuracy = 1))

dicefalse_p
```

###






### Exercise 1

Start a pipe with`tibble()` with variable `m`, and set m to a list of value representing our sample size, then use `rep()` to repeat the function same numbers of times as the sample size. We want 3 different sample size: 10,50, 100000.

```{r rolling-two-dice-bad-assumption-ex-1, exercise = TRUE}

```

```{r rolling-two-dice-bad-assumption-ex-1-hint, eval = FALSE}
tibble(m = c(rep("10", 10), 
             rep("50", 50),
             rep("10000", 10000)))
```

###

### Exercise 2

Use `sample()` to generate integers 1 to 6 for any order.
```{r rolling-two-dice-bad-assumption-ex-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-bad-assumption-ex-2-hint, eval = FALSE}
sample(1:6)
```

###

Remember do use the `:` because it is very convenient for any consecutive integers.

### Exercise 3

Within `sample()`, add another argument `size` set it equal to 1 because we only want to select 1 values from the list of 6 numbers. And click `run` multiple time to see what happened.
```{r rolling-two-dice-bad-assumption-ex-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-bad-assumption-ex-3-hint, eval = FALSE}
sample(1:6, size = 1)
```

###
Now you have run this statement multiple time, yous should realize the number for each one of the six number to appear, should be quite similar, that you haven't realize which number appears the most frequent.


### Exercise 4

Within the `sample()`, add another argument `prob`, let's add in the probability for the number to appear, which is in this case set the value of `prob` to equal to c(0.1,0.1,0.1,0.1,0.25,0.35)`. And run it multiple times.

```{r rolling-two-dice-bad-assumption-ex-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-bad-assumption-ex-4-hint, eval = FALSE}
sample(1:6, size = 1, prob = c(0.1,0.1,0.1,0.1,0.25,0.35))
```

###

This time the result should be easy to see, the 5s and 6s appears alot more frequent than other number, this is what the `prob` argument does, it allow us to manually assign the probability for number to appear during sampling. 

### Exercise 5

Use `mutate()`, set variable `die_1` to the sample() we just created. This should create a tibble with the first column called `m`, and the second column called `die_1`, and all die_1 values is the same.

```{r rolling-two-dice-bad-assumption-ex-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-bad-assumption-ex-5-hint, eval = FALSE}
tibble(m = c(rep("...", ...), 
             rep("...", ...),
             rep("...", ...))) %>%
  mutate(die_1 = sample(1:6, size = 1, prob = c(0.1,0.1,0.1,0.1,0.25,0.35)))
```

###

The reason for why die_1 is all the same, because for the mutate function, it just generate a single value from sample(), and then copy that for every rows in the tibble.

### Exercise 6

Within the same `mutate()` we created use set die_1 to the value of `map_dbl()`, and within `map_dbl()`, set the first argument to m, and formula to `sample()`, don't forget the `~` for `sample()`.
```{r rolling-two-dice-bad-assumption-ex-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-bad-assumption-ex-6-hint, eval = FALSE}
tibble(m = c(rep("10", 10), 
             rep("50", 50),
             rep("10000", 10000))) %>%
  mutate(die_1 = map_dbl(m, ~ sample(1:6, size = 1, prob = c(0.1, 0.1, 0.1, 0.1, 0.25,0.35))))
```

###

Now the number on the column `die_1` should be different, now you can visualize how 6s and 5s appear most frequent due to the probabiility we set for them. 


### Exercise 7

Pipe down your result, now let's create another dice called `die_2`, do the exact same thing again as `die_1`, the only difference should be the variable name.

```{r rolling-two-dice-false-assumption-ex-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-false-assumption-ex-7-hint, eval = FALSE}
... %>%
  mutate(die_2 = map_dbl(m, ~ sample(1:6, size = 1, prob = c(0.1, 0.1, 0.1, 0.1, 0.25,0.35))))
```

### Exercise 8

Use the `mutate()` function once again,set "result" to the value of the sum of `die_1` and `die_2`.

```{r rolling-two-dice-false-assumption-ex-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-false-assumption-ex-8-hint, eval = FALSE}
... %>%
  mutate(result = ... + ... )
```

###

The following will be really similar to the first excercise.

### Exercise 9

Use `summarise()`, only include `m` and `result`.

```{r rolling-two-dice-false-assumption-ex-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-false-assumption-ex-9-hint, eval = FALSE}
... %>%
  summarise(m, result)
```

### Exercise 10

Keep piping down your result, use mutate() and as.factor to change m to a factor.

```{r rolling-two-dice-false-assumption-ex-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-false-assumption-ex-10-hint, eval = FALSE}
... %>%
  mutate(m = as.factor(m))
```


### Exercise 11

Use `mutate()` once again to set m from smallest to largest using `fct_inseq()`.

```{r rolling-two-dice-false-assumption-ex-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-false-assumption-ex-11-hint, eval = FALSE}
... %>%
  mutate(m = fct_inseq(m))
```

###

Let's start plotting!

### Exercise 12

Use `ggplot()` to graph the Empirical Distribution, within `aes()`, set `x = result`, and then add a layer of `geom_histogram()`

```{r rolling-two-dice-false-assumption-ex-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-false-assumption-ex-12-hint, eval = FALSE}
... %>%
  ggplot(aes(...)) +
  geom_histogram()
  
```


### Exercise 13

Use `facet_wrap()` and set the argument to separate the graph into three small distributions. Don't forget the `~` within `facet_wrap()`.

```{r rolling-two-dice-false-assumption-ex-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-false-assumption-ex-13-hint, eval = FALSE}
... +
  facet_wrap( ~ ...)
```

### Exercise 14

Note that you see the red `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Let's get rid of this by adjusting binwidth for our plots, within `geom_histogram()` set "binwidth" equal to 1, and "color" between bins equal to "white".
```{r rolling-two-dice-false-assumption-ex-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-false-assumption-ex-14-hint, eval = FALSE}
... +
geom_histogram(binwidth = ..., color = "...") 
```

###


### Exercise 15

Within `facet_wrap()`, add another argument `scales`, and set it equal to "free". 
```{r rolling-two-dice-false-assumption-ex-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-false-assumption-ex-15-hint, eval = FALSE}
... +
facet_wrap(~ ..., scales = "...")

```

###
This allows the graph to scale freely. 

### Exercise 16

Now look at the values on the y-axis, for each one of the sixth plot the value is different, this is because we have different sample size, and it makes sense for each to have different *count*.  In order to *normalized* the plot, Within `geom_histogram()`, use `aes()` . Inside `aes()`, we use the argument `y = stat(density)` to set it to put percent on y-axis.

```{r rolling-two-dice-false-assumption-ex-16, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-false-assumption-ex-16-hint, eval = FALSE}
...+
    geom_histogram(aes(y = stat(...))) +
  ...
```


### Exercise 17

Now use `scale_x_continuous()` so the x-axis has `breaks` to the sequence between 2 and 12 common difference is 1 using `seq()`. Set the `labels` for the breaks as from 2 to 12.
```{r rolling-two-dice-false-assumption-ex-17, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-false-assumption-ex-17-hint, eval = FALSE}
... +
scale_x_continuous(breaks = seq(...,..., ...), labels = ...:...) 
```

### Exercise 18

Now use `scale_y_continuous()` to put the x-axis in percent format. Within `scale_y_continuous()`, set `labels` to `scales::percent_format()`. Within `percent_format()` set `accuracy` to 1.
```{r rolling-two-dice-false-assumption-ex-18, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-false-assumption-ex-18-hint, eval = FALSE}
... +
  scale_y_continuous(labels = scales::percent_format(...))
```

### Exercise 19

Finally, use `labs()` to add the appropriate title, subtitle, and axis labels.

```{r rolling-two-dice-false-assumption-ex-19, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>


```{r rolling-two-dice-false-assumption-ex-19-hint, eval = FALSE}
... +
  labs(title = "...",subtitle = "...")
```

Reminder: Your plot should look similar to the the one below. 

```{r}
dicefalse_p
```

###

If your assumptions about the process which generates the data (i.e., the data generating mechanism) are false, then it may take a lot of data to see evidence for that falseness. 

## Different data generating mechanisms
###

There are an infinite number of possible data generating mechanisms (DGMs) for every data science problem. 

###

Consider this graph where we have different probability for the 6s to appear, where 0 present a zero chance, 0.2 is 20%, 0.4 is 40%, 0.6 is 60%, 0.8 is 80% and 1 is 100% respectively, every single one of them represent an different Data Generating Mechanism (DGM). Now let's make this plot.

```{r}
# DK: Comments!

dgm_p <- tibble(die1 = list(c(0.2, 0.2, 0.2, 0.2, 0.2, 0), 
                   c(0.16, 0.16, 0.16, 0.16 ,0.16, 0.20), 
                   c(0.12, 0.12, 0.12, 0.12, 0.12, 0.40), 
                   c(0.08, 0.08, 0.08, 0.08, 0.08, 0.60),
                   c(0.04, 0.04, 0.04, 0.04, 0.04, 0.80), 
                   c(0, 0, 0, 0, 0, 1))) %>%
   mutate(die2 = die1) %>%
   mutate(prob = c(.0, .2, .4, .6, .8, 1) ) %>%
   mutate(sample1 = map(die1, ~ sample(1:6, replace = TRUE, 
                                       size = 10000, prob = .))) %>%
   mutate(sample2 = map(die2, ~ sample(1:6, replace = TRUE, 
                                       size = 10000, prob = .))) %>%
   unnest(c(sample1, sample2)) %>%
   mutate(sum = sample1 + sample2) %>%
   mutate(sum = factor(sum, 2:12)) %>%
   group_by(prob, sum) %>%
   summarise(count = n(), .groups = 'drop') %>%
   mutate(perc = count/10000) %>%
   ggplot(aes(x = sum ,y = perc)) + 
    geom_bar(stat = "identity")+
    facet_wrap(~ prob, scales = "free")+
    scale_x_discrete(drop = FALSE) +
    scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
   labs(title = "Empirical Probability Distribution (6 DGM)",
         subtitle = "Sum from rolling two dice, assumptions changes",
         x = "Outcome\nSum of Two Die",
         y = "Probability")

dgm_p 
```

### Exercise 1

Recall `list()`, within `list()` have 6 values, 0.2, 0.2, 0.2, 0.2, 0.2, and 0, where each number represent the probability of dice in our first DGM.
```{r different-data-gener-1, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-1-hint, eval = FALSE}
list(0.2, 0.2, ..., ..., ..., ...)
```


### Exercise 2

Now use `c()` around the 6 values, this should returns the 6 values in a row.
```{r different-data-gener-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-2-hint, eval = FALSE}
list(c(0.2, 0.2, ..., ..., ..., ...))
```


### Exercise 3

Add another 6 values within `list()` - 0.16, 0.16, 0.16, 0.16 ,0.16, 0.20 using use c(), remember to add `,` to seperate the two rows.The 6 value we use hear represent the probability assumptions of the dice for our second DGM.

```{r different-data-gener-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-3-hint, eval = FALSE}
list(c(0.2, 0.2, ..., ..., ..., ...), 
     c(..., ..., ..., ..., ..., ...))
```

### Exercise 4

Applied the same methods for the 3rd DGM which probability is (0.12, 0.12, 0.12, 0.12, 0.12, 0.40), the fourth is (0.08, 0.08, 0.08, 0.08, 0.08, 0.60), the fifth (0.04, 0.04, 0.04, 0.04, 0.04, 0.80), and the sixth DGM (0, 0, 0, 0, 0, 1).
```{r different-data-gener-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-4-hint, eval = FALSE}
list(c(0.2, 0.2, 0.2, 0.2, 0.2, 0), 
     c(0.16, 0.16, 0.16, 0.16 ,0.16, 0.20), 
     c(0.12, 0.12, 0.12, 0.12, 0.12, 0.40), 
     c(0.08, 0.08, 0.08, 0.08, 0.08, 0.60),
     c(0.04, 0.04, 0.04, 0.04, 0.04, 0.80), 
     c(0, 0, 0, 0, 0, 1))
```


### Exercise 5

Start a pipe with `tibble()` set the coloumn name to `die1`, and assign `die1` to the list we just created. Note the difference between a list and a tibble (list-column). This tibble should includes a list of 6 columns with each being `<dbl [6]>`, means that it consist of 6 values which vector is `double`.

```{r different-data-gener-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-5-hint, eval = FALSE}
tibble(die1 = list(c(0.2, 0.2, 0.2, 0.2, 0.2, 0), 
                   c(0.16, 0.16, 0.16, 0.16 ,0.16, 0.20), 
                   c(0.12, 0.12, 0.12, 0.12, 0.12, 0.40), 
                   c(0.08, 0.08, 0.08, 0.08, 0.08, 0.60),
                   c(0.04, 0.04, 0.04, 0.04, 0.04, 0.80), 
                   c(0, 0, 0, 0, 0, 1)))
```


### Exercise 6

Use `mutate()`, create a new column name is `die2`, and set `die2` equal to `die1` as they have the same probability for each DGM.
```{r different-data-gener-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-6-hint, eval = FALSE}
%>%
  mutate(die2 = die1)
```

### Exercise 7

Use `mutate()` again with a new column name `prob`, and set it equal to .0, .2, .4, .6, .8, 1 using `c()`
```{r different-data-gener-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-7-hint, eval = FALSE}
mutate(prob = c(.0, .2, .4, .6, .8, 1)) %>%
```

###

### Exercise 8

Use mutate() create a new variable called `sample1` which equal to `map()`, inside `map()` set the first argument to die1, second argument is the formula `sample()` which has 4 arguments, the first being consecutive value from 1 to 6, second set `replace` equals `TRUE`, third set `size` equal to 10000, and fourth set `prob` equals `.`.
```{r different-data-gener-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-8-hint, eval = FALSE}
mutate(sample1 = map(die1, ~ sample(1:6, replace = TRUE, 
                                       size = 10000, prob = .)))
```

###
The `.` in the `sample()` function is key, as it carries the list-column we create in the tibble, and applied it to the acturlly dice rolling process.

### Exercise 9

Use mutate() create a new variable called `sample12` which equal to `map()`, inside `map()` set the first argument to die1, second argument is the formula `sample()` which has 4 arguments, the first being consecutive value from 1 to 6, second set `replace` equals `TRUE`, third set `size` equal to 10000, and fourth set `prob` equals `.`.
```{r different-data-gener-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-9-hint, eval = FALSE}
mutate(sample2 = map(..., ~ sample(..., replace = TRUE, 
                                       size = ..., prob = .)))
```

###
Now we created the two dice, each roll 10000 times for each individual world of probabilities (DGM).

### Exercise 10

Now use `unnest()`, around `c()` which include two variables `sample1` and `sample2`.
```{r different-data-gener-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-10-hint, eval = FALSE}
unnest(c(..., ...))
```

###
This is a key step because without this step, r would return an error when we sum of the two dice as non-numeric argument, we need `unnest()` to bring it back into regular columns.


### Exercise 11

Use `mutate()` create a new variable called `sum`, and set it equal to the sum of `sample1` and `sample2`.
```{r different-data-gener-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-11-hint, eval = FALSE}
mutate(sum = sample1 + sample2)
```

###
There is a lot of arguments in `mutate()` we haven't try, for example `.keep` which allows you to control which columns from the data are retained in the output.

### Exercise 12

Use `mutate()` again set `sum` equals to `factor()` which have two arguments, where the first being `sum`, and second being `2:12`.
```{r different-data-gener-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-12-hint, eval = FALSE}
mutate(sum = factor(sum, 2:12))
```

###
The reasson we have this step included, is for later when we graph out and separated the 6 distributions, some distribution like the sixth one will only shows a giant bar that says 1, the `factor()` here is giving `sum` levels, and set all 11 possible value from 2 to 12 appear in each distributions. Yet further steps need to be done in later steps to have this fully accomplish.
`
### Exercise 13

Use `group_by()` which have two arguments, `prob` and `sum`.
```{r different-data-gener-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-13-hint, eval = FALSE}
group_by(..., ...)
```

###
The order of the two matters, and it determines the next step of `summarise()`, if we switch between the two the graph will looks completely different.

### Exercise 14

Now use `summarise()` create a new variable called, `count`, and set it equal to `n()`, then add a new argument `.groups` and set it equal to `drop`.
```{r different-data-gener-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-14-hint, eval = FALSE}
summarise(count = n(), .groups = 'drop')
```

###
If we run the `summarise()` without `group_by()`, r will only returns 1 rows, yet with `group_by()`, r will include the rows and condense it by operation, this time is `n()` means count. 

### Exercise 15

Use `mutate()` and create the variable `perc`, and set it equal to `count` divided by 10000.
```{r different-data-gener-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-15-hint, eval = FALSE}
mutate(perc = count/10000)
```

###
This steps would help us consolidate the percentage for each bar in the distribution.

### Exercise 16

Use `ggplot()`, within use `aes()`, which have two argumenst the first we set`x` equal to `sum`, then we set `y` to `perc`. Add the layer of `geom_bar()`.
```{r different-data-gener-16, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-16-hint, eval = FALSE}
%>%
 ggplot(aes(x = ... ,y = ...))+
  geom_bar()
```

###
We use `geom_bar()` here is because `geom_histogram()` won't work because it has two aesthetic, `geom_col()` because later we need to add `stat` which is an unknown paramter in `geom_col()`.



<!-- Six possible states of the world. Or five possible models. Or five possible assumptions. p_6 = c(0, 0.20, 0.4, 0.6, 0.8, 1). Do 10,000 draws for each. The DGM is something which is made --- in theory --- before you even look at your data. So, let's make 5 of them. Of course, there are an infinite number of possible DGMs. -->

### Exercise 17

Within `geom_bar()` set `stat` equal to "identity".
```{r different-data-gener-17, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-17-hint, eval = FALSE}
...+
 geom_bar(stat = "...")
```

###
This allows us to do the counting and stacking up of the bars with the two aesthetic in `ggplot()`.Since we already calculate the percentage before plotting we no longer need the `after_stat()` to help us count the number in the bars.

### Exercise 18

Use `facet_wrap()`, which have the first argument being `~ prob`, second which we set `scales` equal to `free`.
```{r different-data-gener-18, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-18-hint, eval = FALSE}
+
 facet_wrap(~ prob, scales = "free")
```

###
`scales = "free"` allows the distribution to follow the order in the tibble, instead going from numeric order.

### Exercise 19

Use `scale_x_discrete()`, and set `drop` equal to `FALSE`.
```{r different-data-gener-19, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-19-hint, eval = FALSE}
+
  scale_x_discrete(drop = FALSE)

```

###
We are using `scale_x_discrete()` instead `scale_x_dcontinuous()` is because the `factor` step in exercise 12, factors only work for discrete value, and argument `drop` equals `FALSE` is telling r do not drop the columns that have no values in it.

### Exercise 20

Use `scale_y_continuous()` to put the x-axis in percent format. Within `scale_y_continuous()`, set `labels` to `scales::percent_format()`. Within `percent_format()` set `accuracy` to 1.
```{r different-data-gener-20, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-20-hint, eval = FALSE}
... +
  scale_y_continuous(labels = scales::percent_format(...))
```


### Exercise 21

Finally, use `labs()` to add the appropriate title, subtitle, and axis labels.

```{r different-data-gener-21, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-21-hint, eval = FALSE}
... +
  labs(title = "...",subtitle = "...")
```


Reminder: Your plot should look similar to the the one below. 

```{r}
dgm_p
```



## Rejecting a proposed DGM
###

If there is a discrepancy when comparing the DGM models to the real data, this determines that the DGM models need to change or reject.

###

<!-- Someone says: 5s and 6s have a 20% chance, all other numbers have a 15% chance. We simulate that DGM. And we compare --- side by side histograms? overlapping histograms? overlapping densities? maybe use patchwork --- 10,000 data points (generated by dice with 20% chance for *4* and 5 and 6) --- although we are considering this to be real data which someone handed us) with 10,000 points from their DGM. -->

<!-- Maybe data is stacked --- meaning "tidy" --- with a column called "source" with values either "data" or "DGM".  -->

<!--  Shows what happens when we directly compare data  to simulations from the model (which we define as the truth.) With 10,000 draws, it is obvious that the data demonstrates that the model is false. Key is that we are comparing the model with the data and, on the basis of a discrepancy between the two, determining that we need to fix the model. Introduce the concept of model checking. -->

###

Consider the following graph where we simulate a DGM in which we claim that in a fair dice roll that 5s and 6s have a 20% chance, all other numbers have a 15% chance. And then we have the truth where we defined that the dice have 20% chance for *4* and 5 and 6. Then roll the dices 10,000 times for each scenario and calculate the sum of the dices. We can see an clear discrepancy between the DGM and the *Truth*.

```{r}
rej_p <- tibble(die1 = list(c(0.15, 0.15, 0.15, 0.15, 0.20, 0.20), 
                   c(0.13, 0.13, 0.13, 0.20 ,0.20, 0.20))) %>%
         mutate(die2 = die1 ) %>%
         mutate(prob = c("DGM", "Truth")) %>%
         mutate(sample1 = map(die1, ~ sample(1:6, replace = TRUE, size = 10000, prob = .))) %>%
         mutate(sample2 = map(die1, ~ sample(1:6, replace = TRUE, size = 10000, prob = .))) %>%
         unnest(c(sample1, sample2)) %>%
         mutate(sum = sample1 + sample2) %>%
         ggplot(aes(sum)) + 
         geom_histogram(position = "identity", aes(y = stat(density),  fill = prob),
                 binwidth = 1, 
                 color = "black", alpha = 0.5) +
         scale_x_continuous(breaks = seq(2, 12, 1), labels = 2:12) +
         scale_y_continuous(labels= scales::percent_format(accuracy = 1))+
      labs(title = "Empirical Probability Distribution (Rejecting DGM)",
         subtitle = "Sum from rolling two dice, determine the dicrepency between the two distributions",
         x = "Outcome\nSum of Two Die",
         y = "Probability")

rej_p
```

### Exercise 1

Use `list()`, within `list()` have 6 values, 0.15, 0.15, 0.15, 0.15, 0.20, and 0.20 where each number represent the probability of dice in our DGM.
```{r rejecting-a-proposed-1, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-1-hint, eval = FALSE}
list(..., ..., ..., ..., ..., ...)
```

###

### Exercise 2

Now use `c()` around the 6 values, this should returns the 6 values in a row.
```{r rejecting-a-proposed-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-2-hint, eval = FALSE}
list(c(0.15, 0.15, ..., ..., ..., ...))
```

###

### Exercise 3

Add another 6 values within `list()` - 0.13, 0.13, 0.13, 0.20 ,0.20, 0.20 using use c(). The 6 value we use here represent the "truth" model.

```{r rejecting-a-proposed-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-3-hint, eval = FALSE}
list(c(0.15, 0.15, 0.15, 0.15, 0.20, 0.20), 
     c(0.13, 0.13, 0.13, 0.20 ,0.20, 0.20))
```

###

### Exercise 4

Start a pipe with `tibble()` set the coloumn name to `die1`, and assign `die1` to the list we just created. Note the difference between a list and a tibble (list-column). This tibble should includes a list of 6 columns with each being `<dbl [6]>`, means that it consist of 6 values which vector is `double`.

```{r rejecting-a-proposed-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-4-hint, eval = FALSE}
tibble(die1 = list(c(...)))
```

###

### Exercise 5

Use `mutate()`, create a new column name is `die2`, and set `die2` equal to `die1` as they have the same probability for each DGM.
```{r rejecting-a-proposed-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-5-hint, eval = FALSE}
mutate(die2 = ...)
```

###

### Exercise 6

Use `mutate()` create a new variable `prob`, and set it equal to `c()` which include "DGM" and "Truth".
```{r rejecting-a-proposed-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-6-hint, eval = FALSE}
 mutate(prob = c("DGM", "Truth"))
```

###

### Exercise 7

Use mutate() create a new variable called `sample1` which equal to `map()`, inside `map()` set the first argument to die1, second argument is the formula `sample()` which has 4 arguments, the first being consecutive value from 1 to 6, second set `replace` equals `TRUE`, third set `size` equal to 10000, and fourth set `prob` equals `.`.
```{r rejecting-a-proposed-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-7-hint, eval = FALSE}
mutate(sample1 = map(die1, ~ sample(..., replace = TRUE, size = ..., prob = .))) 
```

###

### Exercise 8

Use mutate() create a new variable called `sample2` which equal to `map()`, inside `map()` set the first argument to die1, second argument is the formula `sample()` which has 4 arguments, the first being consecutive value from 1 to 6, second set `replace` equals `TRUE`, third set `size` equal to 10000, and fourth set `prob` equals `.`.
```{r rejecting-a-proposed-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-8-hint, eval = FALSE}
mutate(sample2 = map(die1, ~ sample(..., replace = TRUE, size = ..., prob = .)))
```

###

### Exercise 9

Now use `unnest()`, around `c()` which include two variables `sample1` and `sample2`.

```{r rejecting-a-proposed-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-9-hint, eval = FALSE}
unnest(c(... , ...))
```

###

### Exercise 10

Use `mutate()` create a new variable called `sum`, and set it equal to the sum of `sample1` and `sample2`.
```{r rejecting-a-proposed-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-10-hint, eval = FALSE}
mutate(sum - ... + ...)
```

###

### Exercise 11

 Use `ggplot()`, within use `aes()`, which set`x` equal to `sum`, then add the layer of `geom_histogram()`.
```{r rejecting-a-proposed-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-11-hint, eval = FALSE}
%>%
  ggplot(aes(x=...))+
  geom_histogram()
```

###

### Exercise 12

Within `geom_histogram()` include `aes()`, which set `y` equals `stat(density)`.
```{r rejecting-a-proposed-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-12-hint, eval = FALSE}
geom_histogram(aes(y = stat(...)))
```

###
This step allow us to include both distributions in one graph.

### Exercise 13

Within `geom_histogram()` include another argument `position` and set it also equals to "identity".
```{r rejecting-a-proposed-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-13-hint, eval = FALSE}
geom_histogram(aes(...), position = "...")
```


### Exercise 14

Within `geom_histogram()` add 4 more small arguments, set `fill` equals `prob`, set `binwidth` equal to 1, set `color` equals `"black" and set `alpha` equals `0.5`.
```{r rejecting-a-proposed-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-14-hint, eval = FALSE}
geom_histogram(aes(y = stat(...), position = "...",  fill = ...),
                  binwidth = ..., 
                  color = "...", alpha = ...) 
```

###

### Exercise 15

Now use `scale_x_continuous()` so the x-axis has `breaks` to the sequence between 2 and 12 common difference is 1 using `seq()`. Set the `labels` for the breaks as from 2 to 12.
```{r rejecting-a-proposed-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-15-hint, eval = FALSE}
... +
scale_x_continuous(breaks = seq(...,..., ...), labels = ...:...) 
```

### Exercise 16

Now use `scale_y_continuous()` to put the x-axis in percent format. Within `scale_y_continuous()`, set `labels` to `scales::percent_format()`. Within `percent_format()` set `accuracy` to 1.
```{r rejecting-a-proposed-16, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-16-hint, eval = FALSE}
... +
  scale_y_continuous(labels = scales::percent_format(...))
```

### Exercise 17

Finally, use `labs()` to add the appropriate title, subtitle, and axis labels.
```{r rejecting-a-proposed-17, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-17-hint, eval = FALSE}
... +
  labs(title = "...",subtitle = "...")
```


Reminder: Your plot should look similar to the the one below. 

```{r}
rej_p
```




## Summary
###

The larger the sample size, the more closely your empirical distribution will match the data generating mechanism (DGM) **if** your assumptions about the DGM are correct.

If your assumptions about the process which generates the data (i.e., the data generating mechanism) are false, then it may take a lot of data to see evidence for that falseness. 

There are an infinite number of possible data generating mechanisms (DGMs) for every data science problem. 

If there is a discrepancy when comparing the DGM models to the real data, this determines that the DGM models need to change or reject.


<!-- -->



```{r download-answers, child = "../../child_documents/download_answers.Rmd"}
```
